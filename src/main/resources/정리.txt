
    해싱 알고리즘 쓰는 이유
        db 보안을 위해 비밀번호를 암호화한다
        해싱이란 임의의 문자열로 변경하는 것이다.
        spring security default 해싱알고리즘 bcrypt

    해싱 알고리즘 쓸때 솔트를 쓰는 이유
        미리 문자열을 해싱알고리즘에 돌려 테이블을 만들어 비밀번호를 유추할 수 있다.
        따라서 db에 저장할때 솔트 값을 같이 저장한다
        bcrypt 경우 솔트를 랜덤한 값을 써도 괜찮다, 해싱된 결과 값이 매번 다르다
        bcrypt의 장점 속도를 일부러 늦춰 해커들이 많이 시도하지 못하게 함

        -그럼에도 로그인을 할 수 있는 이유는
         솔트 값은 인코딩할때만 사용하고, 평문과 해시된 값을 다시 해싱하면 원래 해시값이 나온다

    프론트 엔드 라이브러리 설정, 프론트 라이브러리 cdn url 쓰는 것이 아닌 패키지내에 패키지화 시킬 수 있다
        bootstrap 5 되면서 부트스트랩 기능을 구별하기위해 bs 키워드 사용 ex) data-toggle -> data-bs-toggle
        WebJar vs Npm (의존성 관리 툴)
            webjar 단점 라이브러리 업데이터가 느리다
            npm으로 의존성 관리

    뷰 중복 코드 제거
        타임리프 프레그먼트(Fragement) 사용하기

    세션
        서버쪽에 session 메모리가 있고 클라이언트는 session id로 접속한다.
        세션은 기본 timout 30분, 늘릴 수 있지만 세션 메모리가 늘어난다.

    세션이 만료 되더라도 로그인 유지 하고 싶은 방법
        쿠키에 인증 정보를 남겨두고 세션이 만료 됐을 때 쿠키에 남아있는 정보로 인증
        문제 쿠키 탈취 당했을 때 계정 정보 탈취 당함

        - 개선 방법, Username과 토큰을 사용해서 쿠키를 계속해서 바꾸는 것
        - 더 개선 방법 username과 토큰, 시리즈(랜점, 고정) 된 것을 사용해서 쿠키가 탈취 당했는 지 검증하는 것
           username과 토큰으로 인증 (해커) 인증 성공 -> 실제 사용자 토큰 인증 실패하지만 시리즈 유효 => 토큰 탈취된 것으로 판단, 쿠키 모두 삭제

    * JPA 영속성

       Open EntityManager (또는 Session) In View 필터
           요청을 처리하는 전체 프로세스에다가 JPA EntityManger(영속성 컨텍스트)를 바인딩 시켜주는 필터
           뷰를 랜더링 할때까지 영속성 컨텍스를 유지하기 때문에 필요한 데이터를 렌더링 하는 시점에 추가로 읽어올 수 있다
           엔티티 객체 변경은 반드시 트랜젝션 안에서 할 것 - 그래야 트랜젹션 종료 직전 또는 필요한 시점에 변경사항을 DB에 반영

